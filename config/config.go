package config

import (
	"encoding/json"
	"flag"
	"fmt"
	"math/rand"
	"net/http"
	"os"
	"os/exec"
	"strings"
	"time"

	"github.com/higgyhiggy/project-0/file"
)

var name bool
var Cmdout string

type AutoGenerated []struct {
	Text   string `json:"text"`
	Author string `json:"author"`
}

var Word = AutoGenerated{}
var Txtname string

func init() {
	//flags creates the flags
	//-file to specify the name of the file
	flag.BoolVar(&name, "file", false, "file name to open or create")
	// parser reads the flags
	flag.Parse()

	// to seed the random
	rand.Seed(time.Now().UnixNano())
	// opening where we will be extracting the json of quotes
	resp, err := http.Get("https://type.fit/api/quotes")
	//handles the erro if there is one when opening the quiotes page
	if err != nil {
		panic(err)
	}

	//closes requested page so it does not take up our resourse
	defer resp.Body.Close()
	//makes json into our struct to access the fields we need
	err = json.NewDecoder(resp.Body).Decode(&Word)
	//stores the file name that we will be using
	Txtname = file.Create(name)
	// creates the file with the specified name
	f, err := os.Create(Txtname)
	if err != nil {

	}
	//closed the created file since we can use that method for i/o
	defer f.Close()
	//managing the quote by making it smaller when its a long phrase
	shorter := strings.Split(Word[rand.Intn(len(Word))].Text, ".")
	// iterating the throught the modified quotes to be inserted into our file
	for _, v := range shorter {
		// writting into our file but making ever letter upper case
		n2, _ := f.WriteString(strings.ToUpper(v) + "\n")
		//handling the variable declared but not used
		if n2 == 0 {

		}
	}

	//sending cmd to be executed to open the file create with desired editor

	out, _ := exec.Command("code", Txtname).Output()

	if out != nil {
		fmt.Println("the number of byte written to file are " + string(out))
	}
	Cmdout = "the file created is " + string(Txtname) + " by user " + os.Getenv("USER")
	fmt.Println(Cmdout)
	// here is where we handle the cat output to the user

}
